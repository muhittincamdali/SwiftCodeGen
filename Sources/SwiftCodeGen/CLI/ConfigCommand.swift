import ArgumentParser
import Foundation

// MARK: - Config Command

/// Command for managing SwiftCodeGen configuration files.
struct Config: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "Manage SwiftCodeGen configuration files",
        subcommands: [Init.self, Validate.self, Show.self, Edit.self, Export.self],
        defaultSubcommand: Init.self
    )
}

// MARK: - Init Subcommand

extension Config {
    
    /// Initializes a new configuration file.
    struct Init: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Initialize a new configuration file"
        )
        
        @Option(name: .shortAndLong, help: "Output path for the configuration file")
        var output: String = "swiftcodegen.yml"
        
        @Option(name: .shortAndLong, help: "Configuration template to use")
        var template: ConfigTemplate = .standard
        
        @Flag(name: .long, help: "Overwrite existing configuration file")
        var force = false
        
        @Flag(name: .shortAndLong, help: "Enable verbose output")
        var verbose = false
        
        mutating func run() throws {
            let outputURL = URL(fileURLWithPath: output)
            
            if FileManager.default.fileExists(atPath: outputURL.path) && !force {
                throw ValidationError("Configuration file already exists at: \(output). Use --force to overwrite.")
            }
            
            if verbose {
                print("ðŸ“ Creating configuration file with template: \(template.rawValue)")
            }
            
            let content = generateConfigContent(for: template)
            try content.write(to: outputURL, atomically: true, encoding: .utf8)
            
            print("âœ… Created configuration file: \(output)")
            
            if verbose {
                print("")
                print("Next steps:")
                print("  1. Edit \(output) to customize your generators")
                print("  2. Run 'swiftcodegen generate' to generate code")
            }
        }
        
        private func generateConfigContent(for template: ConfigTemplate) -> String {
            switch template {
            case .minimal:
                return generateMinimalConfig()
            case .standard:
                return generateStandardConfig()
            case .full:
                return generateFullConfig()
            case .mock:
                return generateMockConfig()
            case .localization:
                return generateLocalizationConfig()
            case .assets:
                return generateAssetsConfig()
            case .di:
                return generateDIConfig()
            }
        }
        
        private func generateMinimalConfig() -> String {
            """
            # SwiftCodeGen Configuration
            # Minimal template - basic code generation setup
            
            version: "1.0"
            
            generators:
              - type: mock
                input: Sources/Protocols
                output: Sources/Generated/Mocks
            """
        }
        
        private func generateStandardConfig() -> String {
            """
            # SwiftCodeGen Configuration
            # Standard template - common code generation setup
            
            version: "1.0"
            
            # Global options
            options:
              access_level: internal
              generate_imports: true
              header_comment: "Auto-generated by SwiftCodeGen"
            
            # Generator definitions
            generators:
              # Generate mock implementations from protocols
              - type: mock
                input: Sources/Protocols
                output: Sources/Generated/Mocks
                options:
                  prefix: Mock
                  generate_stubs: true
            
              # Generate asset accessors
              - type: assets
                input: Resources/Assets.xcassets
                output: Sources/Generated/Assets.swift
                options:
                  generate_colors: true
                  generate_images: true
            
              # Generate localization accessors
              - type: localization
                input: Resources/Localizable.strings
                output: Sources/Generated/Strings.swift
                options:
                  base_language: en
                  generate_enums: true
            """
        }
        
        private func generateFullConfig() -> String {
            """
            # SwiftCodeGen Configuration
            # Full template - comprehensive code generation setup
            
            version: "1.0"
            
            # Global options affecting all generators
            options:
              access_level: public
              generate_imports: true
              header_comment: |
                Auto-generated by SwiftCodeGen
                Do not modify manually
              indent_style: spaces
              indent_width: 4
              line_length: 120
            
            # Generator definitions
            generators:
              # Mock generator for protocol implementations
              - type: mock
                input: Sources/Protocols
                output: Sources/Generated/Mocks
                options:
                  prefix: Mock
                  suffix: ""
                  generate_stubs: true
                  stub_return_nil: false
                  generate_spy: true
                  track_invocations: true
            
              # Asset catalog generator
              - type: assets
                input: Resources/Assets.xcassets
                output: Sources/Generated/Assets.swift
                options:
                  generate_colors: true
                  generate_images: true
                  generate_data: true
                  use_swiftui: true
                  use_uikit: true
                  namespace: Assets
            
              # Localization strings generator
              - type: localization
                input: Resources
                output: Sources/Generated/Strings.swift
                options:
                  base_language: en
                  generate_enums: true
                  generate_functions: true
                  table_name: Localizable
                  bundle: .main
            
              # Dependency injection container generator
              - type: di
                input: Sources/Services
                output: Sources/Generated/DI
                options:
                  container_name: AppContainer
                  generate_protocols: true
                  generate_mocks: true
                  scope_default: singleton
            
              # Model generator from JSON schemas
              - type: model
                input: Schemas
                output: Sources/Generated/Models
                options:
                  codable: true
                  equatable: true
                  hashable: false
                  sendable: true
                  use_optionals: true
            
            # Custom templates
            templates:
              path: Templates
              
            # Exclusion patterns
            exclude:
              - "**/*Tests*"
              - "**/*Mock*"
              - "**/Generated/*"
            """
        }
        
        private func generateMockConfig() -> String {
            """
            # SwiftCodeGen Configuration
            # Mock-focused template for testing
            
            version: "1.0"
            
            options:
              access_level: internal
              header_comment: "Generated mocks for testing"
            
            generators:
              - type: mock
                input: Sources/Protocols
                output: Tests/Mocks
                options:
                  prefix: Mock
                  generate_stubs: true
                  stub_return_nil: true
                  generate_spy: true
                  track_invocations: true
                  track_arguments: true
                  generate_async: true
                  generate_throws: true
            """
        }
        
        private func generateLocalizationConfig() -> String {
            """
            # SwiftCodeGen Configuration
            # Localization-focused template
            
            version: "1.0"
            
            options:
              access_level: public
              header_comment: "Generated localization accessors"
            
            generators:
              - type: localization
                input: Resources
                output: Sources/Generated/Strings.swift
                options:
                  base_language: en
                  supported_languages:
                    - en
                    - es
                    - fr
                    - de
                    - ja
                  generate_enums: true
                  generate_functions: true
                  generate_plurals: true
                  table_name: Localizable
                  bundle: .main
                  validate_keys: true
                  report_missing: true
            """
        }
        
        private func generateAssetsConfig() -> String {
            """
            # SwiftCodeGen Configuration
            # Assets-focused template
            
            version: "1.0"
            
            options:
              access_level: public
              header_comment: "Generated asset accessors"
            
            generators:
              - type: assets
                input: Resources/Assets.xcassets
                output: Sources/Generated/Assets.swift
                options:
                  generate_colors: true
                  generate_images: true
                  generate_symbols: true
                  generate_data: true
                  use_swiftui: true
                  use_uikit: true
                  namespace: Assets
                  generate_previews: true
                  validate_assets: true
            """
        }
        
        private func generateDIConfig() -> String {
            """
            # SwiftCodeGen Configuration
            # Dependency Injection focused template
            
            version: "1.0"
            
            options:
              access_level: public
              header_comment: "Generated DI container"
            
            generators:
              - type: di
                input: Sources/Services
                output: Sources/Generated/DI
                options:
                  container_name: AppContainer
                  generate_protocols: true
                  generate_mocks: true
                  generate_factory: true
                  scope_default: transient
                  thread_safe: true
                  lazy_resolution: true
            """
        }
    }
}

// MARK: - Config Templates

/// Available configuration templates.
enum ConfigTemplate: String, ExpressibleByArgument, CaseIterable {
    case minimal
    case standard
    case full
    case mock
    case localization
    case assets
    case di
    
    static var allValueStrings: [String] {
        allCases.map { $0.rawValue }
    }
}

// MARK: - Validate Subcommand

extension Config {
    
    /// Validates an existing configuration file.
    struct Validate: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Validate a configuration file"
        )
        
        @Argument(help: "Path to the configuration file")
        var configPath: String = "swiftcodegen.yml"
        
        @Flag(name: .shortAndLong, help: "Enable verbose output")
        var verbose = false
        
        @Flag(name: .long, help: "Check that all referenced paths exist")
        var checkPaths = false
        
        mutating func run() throws {
            let configURL = URL(fileURLWithPath: configPath)
            
            guard FileManager.default.fileExists(atPath: configURL.path) else {
                throw ValidationError("Configuration file not found: \(configPath)")
            }
            
            if verbose {
                print("ðŸ” Validating configuration: \(configPath)")
            }
            
            let config = try CodeGenConfig.load(from: configURL)
            var issues: [ValidationIssue] = []
            
            // Validate version
            if config.version.isEmpty {
                issues.append(.warning("Missing version field"))
            }
            
            // Validate generators
            if config.generators.isEmpty {
                issues.append(.error("No generators defined"))
            }
            
            for (index, generator) in config.generators.enumerated() {
                let prefix = "Generator [\(index)]"
                
                if generator.type.isEmpty {
                    issues.append(.error("\(prefix): Missing type"))
                }
                
                if generator.inputPath.isEmpty {
                    issues.append(.error("\(prefix): Missing input path"))
                }
                
                if generator.outputPath.isEmpty {
                    issues.append(.error("\(prefix): Missing output path"))
                }
                
                if checkPaths {
                    let inputURL = URL(fileURLWithPath: generator.inputPath)
                    if !FileManager.default.fileExists(atPath: inputURL.path) {
                        issues.append(.warning("\(prefix): Input path does not exist: \(generator.inputPath)"))
                    }
                }
            }
            
            // Print results
            let errors = issues.filter { $0.severity == .error }
            let warnings = issues.filter { $0.severity == .warning }
            
            if verbose {
                for issue in issues {
                    switch issue.severity {
                    case .error:
                        print("âŒ \(issue.message)")
                    case .warning:
                        print("âš ï¸  \(issue.message)")
                    }
                }
            }
            
            if errors.isEmpty {
                print("âœ… Configuration is valid (\(warnings.count) warning\(warnings.count == 1 ? "" : "s"))")
            } else {
                print("âŒ Configuration is invalid (\(errors.count) error\(errors.count == 1 ? "" : "s"), \(warnings.count) warning\(warnings.count == 1 ? "" : "s"))")
                throw ExitCode.failure
            }
        }
    }
}

// MARK: - Validation Issue

/// A validation issue found in the configuration.
struct ValidationIssue {
    enum Severity {
        case error
        case warning
    }
    
    let severity: Severity
    let message: String
    
    static func error(_ message: String) -> ValidationIssue {
        ValidationIssue(severity: .error, message: message)
    }
    
    static func warning(_ message: String) -> ValidationIssue {
        ValidationIssue(severity: .warning, message: message)
    }
}

// MARK: - Show Subcommand

extension Config {
    
    /// Shows the current configuration.
    struct Show: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Display the current configuration"
        )
        
        @Argument(help: "Path to the configuration file")
        var configPath: String = "swiftcodegen.yml"
        
        @Option(name: .shortAndLong, help: "Output format")
        var format: OutputFormat = .yaml
        
        @Flag(name: .long, help: "Show only generator summary")
        var summary = false
        
        mutating func run() throws {
            let configURL = URL(fileURLWithPath: configPath)
            
            guard FileManager.default.fileExists(atPath: configURL.path) else {
                throw ValidationError("Configuration file not found: \(configPath)")
            }
            
            let config = try CodeGenConfig.load(from: configURL)
            
            if summary {
                printSummary(config)
            } else {
                switch format {
                case .yaml:
                    let content = try String(contentsOf: configURL, encoding: .utf8)
                    print(content)
                case .json:
                    let encoder = JSONEncoder()
                    encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
                    let data = try encoder.encode(config)
                    print(String(data: data, encoding: .utf8) ?? "")
                case .table:
                    printTable(config)
                }
            }
        }
        
        private func printSummary(_ config: CodeGenConfig) {
            print("Configuration Summary")
            print("=====================")
            print("Version: \(config.version)")
            print("Generators: \(config.generators.count)")
            print("")
            
            for (index, generator) in config.generators.enumerated() {
                print("[\(index + 1)] \(generator.type)")
                print("    Input:  \(generator.inputPath)")
                print("    Output: \(generator.outputPath)")
            }
        }
        
        private func printTable(_ config: CodeGenConfig) {
            let headers = ["#", "Type", "Input", "Output"]
            var rows: [[String]] = []
            
            for (index, generator) in config.generators.enumerated() {
                rows.append([
                    String(index + 1),
                    generator.type,
                    generator.inputPath,
                    generator.outputPath
                ])
            }
            
            let columnWidths = headers.indices.map { col in
                max(
                    headers[col].count,
                    rows.map { $0[col].count }.max() ?? 0
                )
            }
            
            // Print header
            let headerLine = headers.enumerated().map { index, header in
                header.padding(toLength: columnWidths[index], withPad: " ", startingAt: 0)
            }.joined(separator: " | ")
            
            print(headerLine)
            print(String(repeating: "-", count: headerLine.count))
            
            // Print rows
            for row in rows {
                let rowLine = row.enumerated().map { index, value in
                    value.padding(toLength: columnWidths[index], withPad: " ", startingAt: 0)
                }.joined(separator: " | ")
                print(rowLine)
            }
        }
    }
}

// MARK: - Output Formats

/// Output format for configuration display.
enum OutputFormat: String, ExpressibleByArgument, CaseIterable {
    case yaml
    case json
    case table
}

// MARK: - Edit Subcommand

extension Config {
    
    /// Opens the configuration file for editing.
    struct Edit: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Open the configuration file in an editor"
        )
        
        @Argument(help: "Path to the configuration file")
        var configPath: String = "swiftcodegen.yml"
        
        @Option(name: .shortAndLong, help: "Editor to use")
        var editor: String?
        
        mutating func run() throws {
            let configURL = URL(fileURLWithPath: configPath)
            
            guard FileManager.default.fileExists(atPath: configURL.path) else {
                throw ValidationError("Configuration file not found: \(configPath)")
            }
            
            let editorCommand = editor ?? ProcessInfo.processInfo.environment["EDITOR"] ?? "vim"
            
            let process = Process()
            process.executableURL = URL(fileURLWithPath: "/usr/bin/env")
            process.arguments = [editorCommand, configPath]
            
            try process.run()
            process.waitUntilExit()
            
            if process.terminationStatus != 0 {
                throw ValidationError("Editor exited with status: \(process.terminationStatus)")
            }
        }
    }
}

// MARK: - Export Subcommand

extension Config {
    
    /// Exports the configuration to different formats.
    struct Export: ParsableCommand {
        static let configuration = CommandConfiguration(
            abstract: "Export configuration to different formats"
        )
        
        @Argument(help: "Path to the configuration file")
        var configPath: String = "swiftcodegen.yml"
        
        @Option(name: .shortAndLong, help: "Output path")
        var output: String
        
        @Option(name: .shortAndLong, help: "Export format")
        var format: ExportFormat = .json
        
        mutating func run() throws {
            let configURL = URL(fileURLWithPath: configPath)
            
            guard FileManager.default.fileExists(atPath: configURL.path) else {
                throw ValidationError("Configuration file not found: \(configPath)")
            }
            
            let config = try CodeGenConfig.load(from: configURL)
            let outputURL = URL(fileURLWithPath: output)
            
            switch format {
            case .json:
                let encoder = JSONEncoder()
                encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
                let data = try encoder.encode(config)
                try data.write(to: outputURL)
                
            case .swift:
                let swiftCode = generateSwiftConfig(config)
                try swiftCode.write(to: outputURL, atomically: true, encoding: .utf8)
                
            case .env:
                let envContent = generateEnvConfig(config)
                try envContent.write(to: outputURL, atomically: true, encoding: .utf8)
            }
            
            print("âœ… Exported configuration to: \(output)")
        }
        
        private func generateSwiftConfig(_ config: CodeGenConfig) -> String {
            var lines: [String] = []
            
            lines.append("//")
            lines.append("//  CodeGenConfig+Generated.swift")
            lines.append("//  SwiftCodeGen")
            lines.append("//")
            lines.append("")
            lines.append("import Foundation")
            lines.append("")
            lines.append("extension CodeGenConfig {")
            lines.append("    static let generated: CodeGenConfig = {")
            lines.append("        var config = CodeGenConfig.default")
            lines.append("        config.version = \"\(config.version)\"")
            lines.append("        config.options.accessLevel = \"\(config.options.accessLevel)\"")
            lines.append("        config.generators = [")
            
            for generator in config.generators {
                lines.append("            GeneratorEntry(")
                lines.append("                type: \"\(generator.type)\",")
                lines.append("                inputPath: \"\(generator.inputPath)\",")
                lines.append("                outputPath: \"\(generator.outputPath)\"")
                lines.append("            ),")
            }
            
            lines.append("        ]")
            lines.append("        return config")
            lines.append("    }()")
            lines.append("}")
            
            return lines.joined(separator: "\n")
        }
        
        private func generateEnvConfig(_ config: CodeGenConfig) -> String {
            var lines: [String] = []
            
            lines.append("# SwiftCodeGen Environment Configuration")
            lines.append("# Generated from: \(configPath)")
            lines.append("")
            lines.append("SWIFTCODEGEN_VERSION=\(config.version)")
            lines.append("SWIFTCODEGEN_ACCESS_LEVEL=\(config.options.accessLevel)")
            
            for (index, generator) in config.generators.enumerated() {
                let prefix = "SWIFTCODEGEN_GEN\(index)"
                lines.append("\(prefix)_TYPE=\(generator.type)")
                lines.append("\(prefix)_INPUT=\(generator.inputPath)")
                lines.append("\(prefix)_OUTPUT=\(generator.outputPath)")
            }
            
            return lines.joined(separator: "\n")
        }
    }
}

// MARK: - Export Formats

/// Export format options.
enum ExportFormat: String, ExpressibleByArgument, CaseIterable {
    case json
    case swift
    case env
}

// MARK: - Additional CLI Commands

/// Command for listing available generators.
struct Generators: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "List available code generators"
    )
    
    @Flag(name: .shortAndLong, help: "Show detailed information")
    var detailed = false
    
    mutating func run() {
        let generators: [(String, String, [String])] = [
            ("mock", "Generate mock implementations from protocols", [
                "prefix: String - Prefix for generated mock names",
                "suffix: String - Suffix for generated mock names",
                "generate_stubs: Bool - Generate stub return values",
                "generate_spy: Bool - Generate spy tracking"
            ]),
            ("assets", "Generate type-safe asset accessors", [
                "generate_colors: Bool - Generate color accessors",
                "generate_images: Bool - Generate image accessors",
                "use_swiftui: Bool - Generate SwiftUI extensions",
                "use_uikit: Bool - Generate UIKit extensions"
            ]),
            ("localization", "Generate localization string accessors", [
                "base_language: String - Base language code",
                "generate_enums: Bool - Generate enum cases",
                "generate_functions: Bool - Generate formatted functions"
            ]),
            ("di", "Generate dependency injection containers", [
                "container_name: String - Name of the container class",
                "generate_protocols: Bool - Generate protocol definitions",
                "scope_default: String - Default scope (singleton/transient)"
            ]),
            ("model", "Generate Swift models from JSON schemas", [
                "codable: Bool - Conform to Codable",
                "equatable: Bool - Conform to Equatable",
                "sendable: Bool - Conform to Sendable"
            ]),
            ("repository", "Generate repository pattern implementations", [
                "use_async: Bool - Use async/await",
                "use_combine: Bool - Use Combine publishers",
                "data_source: String - Data source type"
            ]),
            ("viewmodel", "Generate ViewModel implementations", [
                "architecture: String - Architecture pattern (MVVM/TCA)",
                "binding: String - Binding mechanism (Combine/Observation)"
            ]),
            ("service", "Generate service layer code", [
                "pattern: String - Service pattern (Basic/Decorator)",
                "caching: String - Caching strategy (Memory/Disk/None)"
            ])
        ]
        
        print("Available Generators")
        print("====================")
        print("")
        
        for (name, description, options) in generators {
            print("ðŸ“¦ \(name)")
            print("   \(description)")
            
            if detailed && !options.isEmpty {
                print("")
                print("   Options:")
                for option in options {
                    print("     â€¢ \(option)")
                }
            }
            print("")
        }
    }
}

// MARK: - Version Command

/// Command for displaying version information.
struct Version: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "Display version information"
    )
    
    @Flag(name: .long, help: "Show detailed build information")
    var build = false
    
    mutating func run() {
        print("SwiftCodeGen v1.0.0")
        
        if build {
            print("")
            print("Build Information:")
            print("  Swift Version: 5.9+")
            print("  Platform: macOS 13+, iOS 16+")
            print("  Architecture: arm64, x86_64")
        }
    }
}

// MARK: - Doctor Command

/// Command for diagnosing configuration issues.
struct Doctor: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "Diagnose configuration and environment issues"
    )
    
    @Argument(help: "Path to the configuration file")
    var configPath: String = "swiftcodegen.yml"
    
    mutating func run() throws {
        print("ðŸ©º SwiftCodeGen Doctor")
        print("======================")
        print("")
        
        var hasIssues = false
        
        // Check Swift version
        print("Checking Swift version...")
        let swiftVersion = getSwiftVersion()
        if let version = swiftVersion {
            print("  âœ… Swift \(version)")
        } else {
            print("  âš ï¸  Could not determine Swift version")
            hasIssues = true
        }
        
        // Check configuration file
        print("")
        print("Checking configuration...")
        let configURL = URL(fileURLWithPath: configPath)
        
        if FileManager.default.fileExists(atPath: configURL.path) {
            print("  âœ… Configuration file found: \(configPath)")
            
            do {
                let config = try CodeGenConfig.load(from: configURL)
                print("  âœ… Configuration is valid")
                print("  âœ… \(config.generators.count) generator(s) configured")
            } catch {
                print("  âŒ Configuration error: \(error.localizedDescription)")
                hasIssues = true
            }
        } else {
            print("  âš ï¸  No configuration file found")
            print("     Run 'swiftcodegen config init' to create one")
        }
        
        // Check input paths
        print("")
        print("Checking input paths...")
        
        if FileManager.default.fileExists(atPath: configURL.path) {
            do {
                let config = try CodeGenConfig.load(from: configURL)
                
                for generator in config.generators {
                    let inputURL = URL(fileURLWithPath: generator.inputPath)
                    if FileManager.default.fileExists(atPath: inputURL.path) {
                        print("  âœ… \(generator.type): \(generator.inputPath)")
                    } else {
                        print("  âŒ \(generator.type): \(generator.inputPath) (not found)")
                        hasIssues = true
                    }
                }
            } catch {
                print("  âš ï¸  Could not check paths")
            }
        }
        
        // Summary
        print("")
        if hasIssues {
            print("âš ï¸  Some issues were found. Please review the output above.")
        } else {
            print("âœ… Everything looks good!")
        }
    }
    
    private func getSwiftVersion() -> String? {
        let process = Process()
        let pipe = Pipe()
        
        process.executableURL = URL(fileURLWithPath: "/usr/bin/swift")
        process.arguments = ["--version"]
        process.standardOutput = pipe
        process.standardError = pipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            if let output = String(data: data, encoding: .utf8) {
                let lines = output.components(separatedBy: "\n")
                if let firstLine = lines.first {
                    return firstLine
                }
            }
        } catch {
            return nil
        }
        
        return nil
    }
}

// MARK: - Clean Command

/// Command for cleaning generated files.
struct Clean: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "Remove generated files"
    )
    
    @Argument(help: "Path to the configuration file")
    var configPath: String = "swiftcodegen.yml"
    
    @Flag(name: .shortAndLong, help: "Don't ask for confirmation")
    var force = false
    
    @Flag(name: .long, help: "Show what would be deleted without deleting")
    var dryRun = false
    
    @Flag(name: .shortAndLong, help: "Enable verbose output")
    var verbose = false
    
    mutating func run() throws {
        let configURL = URL(fileURLWithPath: configPath)
        
        guard FileManager.default.fileExists(atPath: configURL.path) else {
            throw ValidationError("Configuration file not found: \(configPath)")
        }
        
        let config = try CodeGenConfig.load(from: configURL)
        var filesToDelete: [URL] = []
        
        for generator in config.generators {
            let outputURL = URL(fileURLWithPath: generator.outputPath)
            
            if FileManager.default.fileExists(atPath: outputURL.path) {
                var isDirectory: ObjCBool = false
                FileManager.default.fileExists(atPath: outputURL.path, isDirectory: &isDirectory)
                
                if isDirectory.boolValue {
                    if let enumerator = FileManager.default.enumerator(at: outputURL, includingPropertiesForKeys: nil) {
                        while let fileURL = enumerator.nextObject() as? URL {
                            if fileURL.pathExtension == "swift" {
                                filesToDelete.append(fileURL)
                            }
                        }
                    }
                } else {
                    filesToDelete.append(outputURL)
                }
            }
        }
        
        if filesToDelete.isEmpty {
            print("No generated files found to clean.")
            return
        }
        
        if dryRun {
            print("Would delete \(filesToDelete.count) file(s):")
            for file in filesToDelete {
                print("  \(file.path)")
            }
            return
        }
        
        if !force {
            print("This will delete \(filesToDelete.count) file(s). Continue? [y/N] ", terminator: "")
            if let response = readLine(), response.lowercased() != "y" {
                print("Cancelled.")
                return
            }
        }
        
        var deletedCount = 0
        
        for file in filesToDelete {
            do {
                try FileManager.default.removeItem(at: file)
                deletedCount += 1
                if verbose {
                    print("Deleted: \(file.path)")
                }
            } catch {
                print("Failed to delete \(file.path): \(error.localizedDescription)")
            }
        }
        
        print("âœ… Deleted \(deletedCount) file(s)")
    }
}
